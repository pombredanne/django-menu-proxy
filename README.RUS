Предположим, на сайте нам нужны:
* Страницы наполняемые пользовательским контентом
(реализованные в древовидном виде при помощи mptt, например через django-pages-cms).
* Каталог товаров с вложенными разделами и товарами
(реализованные в древовидном виде при помощи mptt, например django-catalog)
* Новости (реализованные как список объектов, получаемых через generic.views,
например django-easy-news)
* Поиск (реализованный отдельной вьюхой)

И мы хотим получить сайт, содержащий в меню следующие разделы:

Главная
Каталог
-О каталоге
-Клавиатуры
--Лот 1
--Лот 2
-Мышь
--Грызун 1
--Грызун 2
--Грызун 3
Новости
-Мы открылись
-Мы начали наполнять сайт
-Мы начали наполнять каталог
-Мы продолжаем наполнять каталог
Важное
-Интересная статья
-Другая статья
Поиск
Контакты


При этом мы хотим:
* при добавлении любого типа элемента (страница, раздел, товар или новость),
он автоматически появлялся в меню.
* при просмотре страницы с любого элеметна (в том числе поиск и например месяц новости)
автоматически строился путь до него (breadcrumb).

Для реализции нам необходимо определить структуру меню.
Так как страницы с контентом имеют древовидную организацию возьмем их за основу
и создадим страницы:

Главная
Каталог
-О каталоге
Новости
Важное
-Интересная статья
-Другая статья
Поиск
Контакты

Для реализации мы напишем:
MENU_PROXY_RULES = {}
MENU_PROXY_RULES['pages'] = {
    'method': 'root',
    'proxy': 'menuproxy.proxies.MenuProxy',
    'model': 'pages.models.Page',
}

Метод 'root' указывает, что правило должно быть использовано в качестве корня меню.
Класс MenuProxy описывает метод полученя заголовка, url-а, дочерних
и родительских элементов, для объектов указанной модели.
MenuProxy предпологает, что у каждого элемента есть поле parent и метод get_ancestors.

MenuProxy позволяет накладывать фильтры и исключать объкты из query_set-ов
дочерних элементов и списка родительских объектов:
MENU_PROXY_RULES['pages'] = {
    'method': 'root',
    'proxy': 'menuproxy.proxies.MenuProxy',
    'model': 'pages.models.Page',
    'children_filter': {'status': 1, },
    'ancestors_exclude': {'status': 0, },
}


Мы не хотим, чтобы сама страница с контентом "Поиск" существовала.
Мы хотим, лишь указать местоположение в меню и название пункта.

Для реализации мы напишем:
MENU_PROXY_RULES['search'] = {
    'method': 'instead',
    'inside': 'pages',
    'point': 'menuproxy.points.get_search_page',
    'proxy': 'menuproxy.proxies.ReverseProxy',
    'args': ['search', ],
    'get_title': 'menuproxy.points.get_search_name',
}

Метод 'instead' указывает, что правило будет заменять элемент в меню.
Значение аргумента 'inside' указывает на правило,
для которого будет производиться замена.
Функция get_search_page должна возвращать страницу,
вместо которой будет отображаться элемент.
Класс ReverseProxy позволяет вызвать функцию django.core.urlresolvers.reverse
для получения ссылки на объект и передать ей аргументы 'args' и 'kwargs'.
'get_title' указывает функцию для получения имени пункта меню
(по умолчанию берется заголовок заменяемой страницы).


Страница "Каталог" нам нужна, на ней будет размещаться не сам каталог,
а страница с описанием акций и т.п.
Структура каталога будет отображаться внутри данного пункта меню.
При этом страница "О каталоге" тоже должна остаться в меню
и содержать пользовательский контент. 

Для реализации мы напишем:
MENU_PROXY_RULES['catalog'] = {
    'method': 'append',
    'inside': 'pages',
    'point': 'menuproxy.points.get_catalog_page',
    'proxy': 'menuproxy.proxies.MenuProxy',
    'children_filter': {'show': True, },
}

Метод 'append' указывает, что правило потомки объекта будут добавлять к потомкам 'point'.
Класс FilterProxy возвоащает список дочерних объектов с использованием фильтра 'kwargs'.


Мы хотим, чтобы сама страница "Новости" содержала архив новостей.

Для реализации мы напишем:
MENU_PROXY_RULES['news_archive'] = {
    'method': 'instead',
    'inside': 'pages',
    'point': 'menuproxy.points.get_news_page',
    'proxy': 'menuproxy.proxies.ReverseProxy',
    'args': ['news_archive_index', ],
    'get_title': 'menuproxy.points.get_news_name',
}

Мы хотим, чтобы внутри раздела "Новости" содержались новости.

Для реализации мы напишем:
MENU_PROXY_RULES['news_detail'] = {
    'method': 'append',
    'inside': 'news_archive',
    'proxy': 'menuproxy.proxies.FlatProxy',
    'model': 'easy_news.models.News',
    'children_filter': {'show': True, },
}

Класс FlatProxy позволяет отображать список всех элементов в моделе. 
Список родителей всегда пуст.


Для отображения меню в шаблон добавим
{% load menuproxy_tags %}
{% show_main_menu %}
Это позволит отобразить все элементы меню верхнего уровня.

Для того, чтобы menuproxy могло подсветить текущий элемент в меню:
{% show_main_menu 'pages' current_page %}

Если мы хотим отобразить полный список всех элементов меню:
{% show_full_menu 'pages' current_page %}

Для отображения только тех разделов, внутри которых находится текущая страница:
{% show_auto_menu  %}

Для отображения меню для вьюхи поиска в её шаблоне укажим:
{% show_auto_menu 'search' %}

Для построения breadcrumb-ов:
{% show_breadcrumbs 'pages' current_page %}
