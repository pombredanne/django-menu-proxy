Предположим, на сайте нам нужны:
* Страницы наполняемые пользовательским контентом
(реализованные в древовидном виде при помощи mptt, например через django-pages-cms).
* Каталог товаров с вложенными разделами и товарами
(реализованные в древовидном виде при помощи mptt, например django-catalog)
* Новости (реализованные как список объектов, получаемых через generic.views,
например django-easy-news)
* Поиск (реализованный отдельной вьюхой)

И мы хотим получить сайт, содержащий в меню следующие разделы:

Главная
Каталог
-О каталоге
-Клавиатуры
--Лот 1
--Лот 2
-Мышь
--Грызун 1
--Грызун 2
--Грызун 3
Новости
-Мы открылись
-Мы начали наполнять сайт
-Мы начали наполнять каталог
-Мы продолжаем наполнять каталог
Важное
-Интересная статья
-Другая статья
Поиск
Контакты


При этом мы хотим:
* при добавлении любого типа элемента (страница, раздел, товар или новость),
он автоматически появлялся в меню.
* при просмотре страницы с любого элеметна (в том числе поиск и например месяц новости)
автоматически строился путь до него (breadcrumb).

Для реализции нам необходимо определить структуру меню.
Так как страницы с контентом имеют древовидную организацию возьмем их за основу
и создадим страницы:

Главная
Каталог
-О каталоге
Новости
Важное
-Интересная статья
-Другая статья
Поиск
Контакты

Для реализации мы напишем:
MENU_PROXY_RULES = {}
MENU_PROXY_RULES['pages'] = {
    'method': 'root',
    'proxy': 'menuproxy.proxies.MenuProxy',
    'model': 'pages.models.Page',
    'children_filter': {'status': 1, },
    'ancestors_exclude': {'status': 0, },
}

Метод 'root' указывает, что правило должно быть использовано в качестве корня меню.
Класс PageProxy описывает метод полученя заголовка, url-а, докерних
и родительских элементов, для указанного объекта.


Мы не хотим, чтобы сама страница с контентом "Поиск" существовала.
Мы хотим, лишь указать местоположение в меню и название пункта.

Для реализации мы напишем:
MENU_PROXY_RULES['search'] = {
    'method': 'instead',
    'inside': 'pages',
    'point': 'menuproxy.points.get_search_page',
    'proxy': 'menuproxy.proxies.ReverseProxy',
    'kwargs': {
        'viewname': 'search',
    }
}
Метод 'instead' указывает, что правило будет заменять элемент в меню.
Значение аргумента 'inside' указывает на правило,
для которого будет производиться замена.
Функция get_search_page должна возвращать страницу,
вместо которой будет отображаться элемент.
Класс ReverseProxy позволяет вызвать функцию django.core.urlresolvers.reverse
для получения ссылки на объект и передать ей аргументы 'args' и 'kwargs'.


Страница "Каталог" нам нужна, на ней будет размещаться не сам каталог,
а страница с описанием акций и т.п.
Структура каталога будет отображаться внутри данного пункта меню.
При этом страница "О каталоге" тоже должна остаться в меню
и содержать пользовательский контент. 

Для реализации мы напишем:
MENU_PROXY_RULES['catalog'] = {
    'method': 'append',
    'inside': 'pages',
    'point': 'menuproxy.points.get_catalog_page',
    'proxy': 'menuproxy.proxies.FilterProxy',
    'kwargs': {
        'show': True,
    }
}

Метод 'append' указывает, что правило потомки объекта будут добавлять к потомкам 'point'.
Класс FilterProxy возвоащает список дочерних объектов с использованием фильтра 'kwargs'.


Мы хотим, чтобы сама страница "Новости" содержала архив новостей.

Для реализации мы напишем:
MENU_PROXY_RULES['news_archive'] = {
    'method': 'instead',
    'inside': 'pages',
    'point': 'menuproxy.points.get_news_page',
    'proxy': 'menuproxy.proxies.ReverseProxy',
    'kwargs': {
        'viewname': 'news_archive',
    }
}

Мы хотим, чтобы внутри раздела "Новости" содержались новости.

Для реализации мы напишем:
MENU_PROXY_RULES['news_detail'] = {
    'method': 'append',
    'inside': 'news_archive',
    'proxy': 'menuproxy.proxies.FlatProxy',
}

Класс FlatProxy позволяет отображать 
Если 'point' не указано, используется

Метод 'instead' указывает, что правило будет заменять элемент в меню.
Функция get_search_page должна возвращать страницу,
вместо которой будет отображаться элемент.
Класс ReverseProxy позволяет вызвать функцию django.core.urlresolvers.reverse
для получения ссылки на объект и передать ей аргументы 'args' и 'kwargs'.
